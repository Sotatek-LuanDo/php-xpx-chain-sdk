<?php
/**
 * NIS2 API
 *
 * This document defines all the nis2 api routes and behaviour
 *
 * OpenAPI spec version: 1.0.0
 * Contact: greg@evias.be
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 * 
 */

namespace Proximax\Model\Transaction;

use Proximax\Model\TransactionType;
use Proximax\Model\Deadline;
use Proximax\Model\TransactionVersion;
use Proximax\Model\TransactionInfo;
use Proximax\Model\PublicAccount;
use Proximax\Infrastructure\Network;
use Proximax\Model\Transaction\Schema\TransferTransactionSchema;
use \Google\FlatBuffers\FlatbufferBuilder;
use \Catapult\Buffers\MessageBuffer;
use \Catapult\Buffers\MosaicBuffer;
use \Catapult\Buffers\TransferTransactionBuffer;
use Proximax\Utils\Utils;
use Proximax\Utils\Hex;
use Proximax\Model\AbstractTransaction;
use Base32\Base32;
use Proximax\Model\Address;
use Proximax\Model\NamespaceId;

/**
 * TransferTransaction class Doc Comment
 *
 * @category class
 * @package  Proximax
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TransferTransaction extends \Proximax\Model\Transaction{

    private $recipient;
    private $mosaics; //array
    private $message;
     
    public function __construct($deadline, $address, $mosaics, $message, $networkType){
        $version = TransactionVersion::TRANSFER_VERSION;
        $type = hexdec(TransactionType::TRANSFER);
        if (is_string($networkType) && in_array(strtolower($networkType), ["mijin", "mijintest", "public", "publictest", "private", "privatetest", "NotSupportedNet", "aliasaddress"])){
            $networkType = Network::$networkInfos[strtolower($networkType)]["id"];
        }
        else if (is_numeric($networkType) && !in_array($networkType, [96, 144, 184, 168, 200, 176, 0, 145])) {
            throw new NISInvalidNetworkId("Invalid netword ID '" . $networkType . "'");
        } 
        $maxFee = array(0,0);
        $signature = ""; 
        $signer = new PublicAccount;
        $transactionInfo = new TransactionInfo;

        $abstractTransaction = new AbstractTransaction($transactionInfo,$deadline,$networkType,
                                                    $type,$version,$maxFee,$signature,$signer);
        $this->setAbstractTransaction($abstractTransaction);
        $this->recipient = $address;
        $this->mosaics = $mosaics;
        $this->message = $message;
    }

    public function generateBytes() {
        $networkType = $this->getAbstractTransaction()->getNetworkType();
        $version = $this->getAbstractTransaction()->getVersion();
        $deadline = $this->getAbstractTransaction()->getDeadline();
        $signature = $this->getAbstractTransaction()->getSignature();
        $signer = $this->getAbstractTransaction()->getSigner();
        $maxFee = $this->getAbstractTransaction()->getMaxFee();
        $type = $this->getAbstractTransaction()->getType();

        $message = $this->message;
        $mosaics = $this->mosaics;
        $address = $this->recipient;

        $builder = new FlatbufferBuilder(1);
        
        // Create Message
        $bytePayload = $message->payload;
        $payload = MessageBuffer::createPayloadVector($builder, $bytePayload);
        MessageBuffer::startMessageBuffer($builder);
        MessageBuffer::addType($builder, $message->type);
        MessageBuffer::addPayload($builder, $payload);
        $messageVector = MessageBuffer::endMessageBuffer($builder);

        // Create Mosaics
        for ($i = 0; $i < count($mosaics); ++$i) {
            $mosaic = $mosaics[$i];
            $id = MosaicBuffer::createIdVector($builder, $mosaic->id);
            $amount = MosaicBuffer::createAmountVector($builder, $mosaic->amount);

            MosaicBuffer::startMosaicBuffer($builder);
            MosaicBuffer::addId($builder, $id);
            MosaicBuffer::addAmount($builder, $amount);
            $mosaicBuffers[$i] = MosaicBuffer::endMosaicBuffer($builder);
        }
        // serialize the recipient
        if ($address instanceof NamespaceId){
            $address = $this->newAddressFromNamespaceId($address->getId());
            $recipientBytes = (new Utils)->stringToByteArray(Base32::decode($address));
        }
        else if ($address instanceof Address){
            $recipientBytes = (new Utils)->stringToByteArray(Base32::decode($address->address));
        }
        
        $v = ($networkType << 24) + $version;
        // Create Vectors
        $signatureVector = TransferTransactionBuffer::createSignatureVector($builder, (new Utils)->createArrayZero(64));
        $signerVector = TransferTransactionBuffer::createSignerVector($builder, (new Utils)->createArrayZero(32));
        $recipientVector = TransferTransactionBuffer::createRecipientVector($builder, $recipientBytes);
        $mosaicsVector = TransferTransactionBuffer::createMosaicsVector($builder, $mosaicBuffers);
        $deadlineVector = TransferTransactionBuffer::createDeadlineVector($builder, $deadline->getTimeArray());
        $feeVector = TransferTransactionBuffer::createMaxFeeVector($builder, $maxFee);
        

        // total size of transaction
        $size = 
              // header
              self::HEADER_SIZE + 
              // recipient is always 25 bytes
              25 + 
              // message size is short
              2 +
              // message type byte
              1 + 
              // number of mosaics
              1 + 
              // each mosaic has id and amount, both 8byte uint64
              ((8 + 8) * count($mosaics)) + 
              // number of message bytes
              count($bytePayload);

        TransferTransactionBuffer::startTransferTransactionBuffer($builder);
        TransferTransactionBuffer::addSize($builder, $size);
        TransferTransactionBuffer::addSignature($builder, $signatureVector);
        TransferTransactionBuffer::addSigner($builder, $signerVector);
        TransferTransactionBuffer::addVersion($builder, $v);
        TransferTransactionBuffer::addType($builder, $type);
        TransferTransactionBuffer::addMaxFee($builder, $feeVector);
        TransferTransactionBuffer::addDeadline($builder, $deadlineVector);
        
        TransferTransactionBuffer::addRecipient($builder, $recipientVector);
        TransferTransactionBuffer::addNumMosaics($builder, count($mosaics));
        TransferTransactionBuffer::addMessageSize($builder, count($bytePayload) + 1);
        TransferTransactionBuffer::addMessage($builder, $messageVector);
        TransferTransactionBuffer::addMosaics($builder, $mosaicsVector);
        
        $codedTransaction = TransferTransactionBuffer::endTransferTransactionBuffer($builder);
        
        $builder->finish($codedTransaction);
        $TransferTransactionSchema = new TransferTransactionSchema;
        $tmp = unpack("C*",$builder->sizedByteArray());
        $builder_byte = array_slice($tmp,0,count($tmp));
        $output = $TransferTransactionSchema->serialize($builder_byte);
        return $output;
    }

    private function newAddressFromNamespaceId($namespaceId){
        $p1 = (new Utils)->intToArray($namespaceId[0]);
        $p2 = (new Utils)->intToArray($namespaceId[1]);
        $namespaceB = array_merge((new Utils)->ReverseByteArray($p1), (new Utils)->ReverseByteArray($p2));
        $a = dechex(Network::getIdfromName("AliasAddress"));
        $a .= (new Hex)->EncodeToString($namespaceB);
        $a .= "00000000000000000000000000000000";

        $ph = (new Hex)->DecodeString($a);
        $parse = Base32::encode(implode(array_map("chr", $ph)));
        return $parse;
    }
}
?>