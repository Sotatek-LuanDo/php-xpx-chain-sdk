<?php
/**
 * NIS2 API
 *
 * This document defines all the nis2 api routes and behaviour
 *
 * OpenAPI spec version: 1.0.0
 * Contact: greg@evias.be
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 * 
 */

namespace Proximax\Model\Transaction;
use Proximax\Model\TransactionType;
use Proximax\Model\Deadline;
use Proximax\Model\TransactionVersion;
use Proximax\Model\TransactionInfo;
use Proximax\Model\PublicAccount;
use Proximax\Infrastructure\Network;
use Proximax\Model\Transaction\Schema\ModifyMetadataTransactionSchema;
use \Google\FlatBuffers\FlatbufferBuilder;
use \Catapult\Buffers\ModifyMetadataTransactionBuffer;
use \Catapult\Buffers\MetadataModificationBuffer;
use Proximax\Utils\Utils;
use Proximax\Model\AbstractTransaction;
use Base32\Base32;
use Proximax\Model\MetadataType;
use Proximax\Model\NamespaceId;
use Proximax\Model\MosaicId;
use Proximax\Model\Address;
use Proximax\Model\MetadataModificationType;

/**
 * ModifyMetadataTransaction class Doc Comment
 *
 * @category class
 * @package  Proximax
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ModifyMetadataTransaction extends \Proximax\Model\Transaction{

    private $metadataType; //MetadataType

    private $metadataId;

    private $address; //Address

    private $modifications; //array MetadataModification
     
    public function __construct($deadline, $parameter, $modifications, $networkType){
        $version = "";
        $type = "";
        if (is_string($networkType) && in_array(strtolower($networkType), ["mijin", "mijintest", "public", "publictest", "private", "privatetest", "NotSupportedNet", "aliasaddress"])){
            $networkType = Network::$networkInfos[strtolower($networkType)]["id"];
        }
        else if (is_numeric($networkType) && !in_array($networkType, [96, 144, 184, 168, 200, 176, 0, 145])) {
            throw new NISInvalidNetworkId("Invalid netword ID '" . $networkType . "'");
        } 
        $maxFee = array(0,0);
        $signature = ""; 
        $signer = new PublicAccount;
        $transactionInfo = new TransactionInfo;

        $abstractTransaction = new AbstractTransaction($transactionInfo,$deadline,$networkType,
                                                    $type,$version,$maxFee,$signature,$signer);
        $this->setAbstractTransaction($abstractTransaction);

        if ($parameter instanceof Address){
            $this->address = $parameter;
            $this->namespaceId = null;

        }
        else if ($parameter instanceof NamespaceId){
            $this->address = null;
            $this->namespaceId = $parameter;

        }
        else if ($parameter instanceof MosaicId){
            $this->address = null;
            $this->namespaceId = $parameter;

        }
        $this->modifications = $modifications;
    }

    public function createForMosaic(){
        $this->getAbstractTransaction()->setVersion(TransactionVersion::METADATA_MOSAIC_VERSION);
        $this->getAbstractTransaction()->setType(hexdec(TransactionType::METADATA_MOSAIC));
        $this->metadataType = MetadataType::MOSAIC;
    }

    public function createForNamespace(){
        $this->getAbstractTransaction()->setVersion(TransactionVersion::METADATA_NAMESPACE_VERSION);
        $this->getAbstractTransaction()->setType(hexdec(TransactionType::METADATA_NAMESPACE));
        $this->metadataType = MetadataType::NAMESPACE;
    }

    public function createForAddress(){
        $this->getAbstractTransaction()->setVersion(TransactionVersion::METADATA_ADDRESS_VERSION);
        $this->getAbstractTransaction()->setType(hexdec(TransactionType::METADATA_ADDRESS));
        $this->metadataType = MetadataType::ADDRESS;
    }

    public function generateBytes() {
        $networkType = $this->getAbstractTransaction()->getNetworkType();
        $version = $this->getAbstractTransaction()->getVersion();
        $deadline = $this->getAbstractTransaction()->getDeadline();
        $signature = $this->getAbstractTransaction()->getSignature();
        $signer = $this->getAbstractTransaction()->getSigner();
        $maxFee = $this->getAbstractTransaction()->getMaxFee();
        $type = $this->getAbstractTransaction()->getType();

        $metadataType = $this->metadataType;
        $modifications = $this->modifications;
        $address = $this->address;
        $namespaceId = $this->namespaceId;

        $builder = new FlatbufferBuilder(1);
        
        if ($address !== null){
            $tmp = Base32::decode($address->toClean());
            $metadataIdBytes = (new Utils)->stringToByteArray($tmp);
        }
        else if ($namespaceId !== null){
            $metadataIdBytes = (new Utils)->getBytes($namespaceId->getId());
        }
        else if ($mosaicId !== null){
            $metadataIdBytes = (new Utils)->getBytes($mosaicId->getId());
        }

        // track the size of the whole metadata modification
        $totalSize = 0;
        // load modifications
        $modificationOffsets = array();
        for ($i=0;$i<count($modifications);$i++) {
            $mod = $modifications[$i];
            $modType = $mod->getType();
            // prepare intermediate data
            $keyBytes = (new Utils)->stringToByteArray($mod->getKey());
            if ($modType == MetadataModificationType::REMOVE){
                $valueBytes = array();
            }
            else $valueBytes = (new Utils)->stringToByteArray($mod->getValue());

            // value size needs special handling to make sure 0 is serialized as 4 bytes, not as 1
            $valueSizeBytes = (new Utils)->putUint16LittleEndian(count($valueBytes));

            // prepare vectors for collections
            $keyOffset = MetadataModificationBuffer::createKeyVector($builder, $keyBytes);
            $valueOffset = MetadataModificationBuffer::createValueVector($builder, $valueBytes);
            $valueSizeOffset = MetadataModificationBuffer::createValueSizeVector($builder, $valueSizeBytes);

            // compute number of bytes: size + modType + keySize + valueSize + key + value
            $modSize = 4 + 1 + 1 + 2 + count($keyBytes) + count($valueBytes);
            // increase total size
            $totalSize += $modSize;

            // populate flat-buffer
            MetadataModificationBuffer::startMetadataModificationBuffer($builder);
            MetadataModificationBuffer::addSize($builder, $modSize);
            MetadataModificationBuffer::addKeySize($builder, count($keyBytes));
            MetadataModificationBuffer::addKey($builder, $keyOffset);
            MetadataModificationBuffer::addValueSize($builder, $valueSizeOffset);
            MetadataModificationBuffer::addValue($builder, $valueOffset);
            MetadataModificationBuffer::addModificationType($builder, $modType);
            $modificationOffsets[$i] = MetadataModificationBuffer::endMetadataModificationBuffer($builder);
        }
        
        $v = ($networkType << 8) + $version;

        // Create Vectors
        $signatureVector = ModifyMetadataTransactionBuffer::createSignatureVector($builder, (new Utils)->createArrayZero(64));
        $signerVector = ModifyMetadataTransactionBuffer::createSignerVector($builder, (new Utils)->createArrayZero(32));
        $deadlineVector = ModifyMetadataTransactionBuffer::createDeadlineVector($builder, $deadline->getTimeArray());
        $feeVector = ModifyMetadataTransactionBuffer::createMaxFeeVector($builder, $maxFee);

        $metadataIdOffset = ModifyMetadataTransactionBuffer::createMetadataIdVector($builder, $metadataIdBytes);
        $modificationsOffset = ModifyMetadataTransactionBuffer::createModificationsVector($builder, $modificationOffsets);

        // add size of stuff with constant size and size of metadata id
        $totalSize += 120 + count($metadataIdBytes) + 1;

        ModifyMetadataTransactionBuffer::startModifyMetadataTransactionBuffer($builder);
        ModifyMetadataTransactionBuffer::addSize($builder, $totalSize);
        ModifyMetadataTransactionBuffer::addSignature($builder, $signatureVector);
        ModifyMetadataTransactionBuffer::addSigner($builder, $signerVector);
        ModifyMetadataTransactionBuffer::addVersion($builder, $v);
        ModifyMetadataTransactionBuffer::addType($builder, $type);
        ModifyMetadataTransactionBuffer::addMaxFee($builder, $feeVector);
        ModifyMetadataTransactionBuffer::addDeadline($builder, $deadlineVector);

        ModifyMetadataTransactionBuffer::addMetadataId($builder, $metadataIdOffset);
        ModifyMetadataTransactionBuffer::addMetadataType($builder, $metadataType);
        ModifyMetadataTransactionBuffer::addModifications($builder, $modificationsOffset);
        
        $codedTransaction = ModifyMetadataTransactionBuffer::endModifyMetadataTransactionBuffer($builder);
        
        $builder->finish($codedTransaction);
        $ModifyMetadataTransactionSchema = new ModifyMetadataTransactionSchema;
        
        $tmp = unpack("C*",$builder->sizedByteArray());
        $builder_byte = array_slice($tmp,0,count($tmp));
        $output = $ModifyMetadataTransactionSchema->serialize($builder_byte);
        return $output;
    }

    private function getValueBytesFromAddressModification($mod){
        $address = $mod->getValue()->toClean();
        $tmp = Base32::decode($address);
        $bytes = (new Utils)->stringToByteArray($tmp);
        return $bytes;
    }

    private function getValueBytesFromMosaicModification($mod){
        $id = $mod->getValue()->getId();
        $bytes = (new Utils)->getBytes($id);
        return $bytes;
    }

    private function getValueBytesFromEntityModification($mod){
        $bytes = (new Utils)->putUint16LittleEndian(hexdec($mod->getValue()));
        return $bytes;
    }
}
?>