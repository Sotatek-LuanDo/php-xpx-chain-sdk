<?php
/**
 * NIS2 API
 *
 * This document defines all the nis2 api routes and behaviour
 *
 * OpenAPI spec version: 1.0.0
 * Contact: greg@evias.be
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 * 
 */

namespace Proximax\Model\Transaction;
use Proximax\Model\TransactionType;
use Proximax\Model\Deadline;
use Proximax\Model\TransactionVersion;
use Proximax\Model\TransactionInfo;
use Proximax\Model\PublicAccount;
use Proximax\Infrastructure\Network;
use Proximax\Model\Transaction\Schema\ModifyContractTransactionSchema;
use \Google\FlatBuffers\FlatbufferBuilder;
use \Catapult\Buffers\ModifyContractTransactionBuffer;
use \Catapult\Buffers\CosignatoryModificationBuffer;
use Proximax\Utils\Utils;
use Proximax\Model\AbstractTransaction;

/**
 * ModifyContractTransaction class Doc Comment
 *
 * @category class
 * @package  Proximax
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ModifyContractTransaction extends \Proximax\Model\Transaction{

    private $durationDelta; //bigInt

    private $contentHash; //string

    private $customersModifications; //MultisigCosignatoryModification

    private $executorsModifications; //MultisigCosignatoryModification

    private $verifiersModifications; //MultisigCosignatoryModification
     
    public function __construct($deadline, $durationDelta, $contentHash, $customersModifications, $executorsModifications, $verifiersModifications, $networkType){
        $version = TransactionVersion::MODIFY_CONTRACT_VERSION;
        $type = hexdec(TransactionType::MODIFY_CONTRACT);
        if (is_string($networkType) && in_array(strtolower($networkType), ["mijin", "mijintest", "public", "publictest", "private", "privatetest", "NotSupportedNet", "aliasaddress"])){
            $networkType = Network::$networkInfos[strtolower($networkType)]["id"];
        }
        else if (is_numeric($networkType) && !in_array($networkType, [96, 144, 184, 168, 200, 176, 0, 145])) {
            throw new NISInvalidNetworkId("Invalid netword ID '" . $networkType . "'");
        } 
        $maxFee = array(0,0);
        $signature = ""; 
        $signer = new PublicAccount;
        $transactionInfo = new TransactionInfo;

        $abstractTransaction = new AbstractTransaction($transactionInfo,$deadline,$networkType,
                                                    $type,$version,$maxFee,$signature,$signer);
        $this->setAbstractTransaction($abstractTransaction);

        $this->durationDelta = $durationDelta;
        $this->contentHash = $contentHash;
        $this->customersModifications = $customersModifications;
        $this->executorsModifications = $executorsModifications;
        $this->verifiersModifications = $verifiersModifications;
    }

    public function generateBytes() {
        $networkType = $this->getAbstractTransaction()->getNetworkType();
        $version = $this->getAbstractTransaction()->getVersion();
        $deadline = $this->getAbstractTransaction()->getDeadline();
        $signature = $this->getAbstractTransaction()->getSignature();
        $signer = $this->getAbstractTransaction()->getSigner();
        $maxFee = $this->getAbstractTransaction()->getMaxFee();
        $type = $this->getAbstractTransaction()->getType();

        $durationDelta = $this->durationDelta;
        $contentHash = $this->contentHash;
        $customersModifications = $this->customersModifications;
        $executorsModifications = $this->executorsModifications;
        $verifiersModifications = $this->verifiersModifications;

        $builder = new FlatbufferBuilder(1);
        
        // Create Modifications
        $customersBuffer = $this->createCosigModificationVector($builder, $customersModifications);
        $executorsBuffer = $this->createCosigModificationVector($builder, $executorsModifications);
        $verifiersBuffer = $this->createCosigModificationVector($builder, $verifiersModifications);

        // serialize content hash to byte array
        $contentHashBytes = (new Utils)->HexDecodeStringOdd($contentHash);

        $v = ($networkType << 8) + $version;

        // Create Vectors
        $signatureVector = ModifyContractTransactionBuffer::createSignatureVector($builder, (new Utils)->createArrayZero(64));
        $signerVector = ModifyContractTransactionBuffer::createSignerVector($builder, (new Utils)->createArrayZero(32));
        $deadlineVector = ModifyContractTransactionBuffer::createDeadlineVector($builder, $deadline->getTimeArray());
        $feeVector = ModifyContractTransactionBuffer::createMaxFeeVector($builder, $maxFee);

        $durationDeltaOffset = ModifyContractTransactionBuffer::createDurationDeltaVector($builder, (new Utils)->fromBigInt($durationDelta));
        $hashOffset = ModifyContractTransactionBuffer::createHashVector($builder, $contentHashBytes);
        $customersOffset = ModifyContractTransactionBuffer::createCustomersVector($builder, $customersBuffer);
        $executorsOffset = ModifyContractTransactionBuffer::createExecutorsVector($builder, $executorsBuffer);
        $verifiersOffset = ModifyContractTransactionBuffer::createVerifiersVector($builder, $verifiersBuffer);

        // standard fields + duration delta + hash length + 3 modification lengths + 33 bytes per every modification (1 byte mod type + 32 bytes public key)
        $totalSize = 120 + 8 + count($contentHashBytes) + 3 + 33 * (count($customersBuffer) + count($executorsBuffer) + count($verifiersBuffer));

        ModifyContractTransactionBuffer::startModifyContractTransactionBuffer($builder);
        ModifyContractTransactionBuffer::addSize($builder, $totalSize);
        ModifyContractTransactionBuffer::addSignature($builder, $signatureVector);
        ModifyContractTransactionBuffer::addSigner($builder, $signerVector);
        ModifyContractTransactionBuffer::addVersion($builder, $v);
        ModifyContractTransactionBuffer::addType($builder, $type);
        ModifyContractTransactionBuffer::addMaxFee($builder, $feeVector);
        ModifyContractTransactionBuffer::addDeadline($builder, $deadlineVector);

        ModifyContractTransactionBuffer::addDurationDelta($builder, $durationDeltaOffset);
        ModifyContractTransactionBuffer::addHash($builder, $hashOffset);
        ModifyContractTransactionBuffer::addNumCustomers($builder, count($customersBuffer));
        ModifyContractTransactionBuffer::addNumExecutors($builder, count($executorsBuffer));
        ModifyContractTransactionBuffer::addNumVerifiers($builder, count($verifiersBuffer));
        ModifyContractTransactionBuffer::addCustomers($builder, $customersOffset);
        ModifyContractTransactionBuffer::addExecutors($builder, $executorsOffset);
        ModifyContractTransactionBuffer::addVerifiers($builder, $verifiersOffset);
        
        $codedTransaction = ModifyContractTransactionBuffer::endModifyContractTransactionBuffer($builder);
        
        $builder->finish($codedTransaction);
        $ModifyContractTransactionSchema = new ModifyContractTransactionSchema;
        
        $tmp = unpack("C*",$builder->sizedByteArray());
        $builder_byte = array_slice($tmp,0,count($tmp));
        $output = $ModifyContractTransactionSchema->serialize($builder_byte);
        return $output;
    }

    /**
    * create vector for cosignatory modifications
    * 
    * @param builder the flatbuffer builder
    * @param modifications list of cosignatory modifications
    * @return array of buffer offsets for modification
    */
    private function createCosigModificationVector($builder, $modifications) {
        // create array for vector offsets
        $modificationsBuffers = array();
        // go over all modifications and prepare the buffers
        for ($i=0;$i<count($modifications);++$i) {
            $multisigCosignatoryModification = $modifications[$i];
            // serialize public key
            $cosignatoryPublicKeyBytes = (new Utils)->HexDecodeStringOdd($multisigCosignatoryModification->getPublicAccount()->getPublicKey());
            // get vector offset for the public key
            $cosignatoryPublicKeyOffset = CosignatoryModificationBuffer::createCosignatoryPublicKeyVector($builder, $cosignatoryPublicKeyBytes);
            // create buffer and add it to the array
            CosignatoryModificationBuffer::startCosignatoryModificationBuffer($builder);
            CosignatoryModificationBuffer::addType($builder, $multisigCosignatoryModification->getType());
            CosignatoryModificationBuffer::addCosignatoryPublicKey($builder, $cosignatoryPublicKeyOffset);
            $modificationsBuffers[$i] = CosignatoryModificationBuffer::endCosignatoryModificationBuffer($builder);
        }
        return $modificationsBuffers;
    }
}
?>