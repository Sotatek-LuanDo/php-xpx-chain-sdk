<?php
/**
 * NIS2 API
 *
 * This document defines all the nis2 api routes and behaviour
 *
 * OpenAPI spec version: 1.0.0
 * Contact: greg@evias.be
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 * 
 */

namespace Proximax\Model\Transaction;

use Proximax\Model\TransactionType;
use Proximax\Model\Deadline;
use Proximax\Model\TransactionVersion;
use Proximax\Model\TransactionInfo;
use Proximax\Model\PublicAccount;
use Proximax\Infrastructure\Network;
use Proximax\Model\Transaction\Schema\RegisterNamespaceTransactionSchema;
use \Google\FlatBuffers\FlatbufferBuilder;
use \Catapult\Buffers\RegisterNamespaceTransactionBuffer;
use Proximax\Utils\Utils;
use Proximax\Model\AbstractTransaction;
use Proximax\Model\NamespaceType;
use Proximax\Model\Transaction\IdGenerator;
/**
 * RegisterNamespaceTransaction class Doc Comment
 *
 * @category class
 * @package  Proximax
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class RegisterNamespaceTransaction extends \Proximax\Model\Transaction{

    private $namespaceName;

    private $namespaceId; 

    private $namespaceType;

    private $duration;

    private $parentId;
     
    public function NewRegisterRootNamespaceTransaction($deadline, $namespaceName, $duration, $networkType){
        $version = TransactionVersion::REGISTER_NAMESPACE_VERSION;
        $type = hexdec(TransactionType::REGISTER_NAMESPACE);
        if (is_string($networkType) && in_array(strtolower($networkType), ["mijin", "mijintest", "public", "publictest", "private", "privatetest", "NotSupportedNet", "aliasaddress"])){
            $networkType = Network::$networkInfos[strtolower($networkType)]["id"];
        }
        else if (is_numeric($networkType) && !in_array($networkType, [96, 144, 184, 168, 200, 176, 0, 145])) {
            throw new NISInvalidNetworkId("Invalid netword ID '" . $networkType . "'");
        } 
        $maxFee = array(0,0);
        $signature = ""; 
        $signer = new PublicAccount;
        $transactionInfo = new TransactionInfo;

        $abstractTransaction = new AbstractTransaction($transactionInfo,$deadline,$networkType,
                                                    $type,$version,$maxFee,$signature,$signer);
        $this->setAbstractTransaction($abstractTransaction);
        $this->namespaceName = $namespaceName;
        $this->namespaceId = IdGenerator::NewNamespaceIdFromName($namespaceName);
        $this->namespaceType = NamespaceType::ROOT;
        $this->duration = $duration;
        $this->parentId = array(0,0);

        return $this;
    }
    
    public function NewRegisterSubNamespaceTransaction($deadline, $namespaceName, $parentName, $networkType){
        $version = TransactionVersion::REGISTER_NAMESPACE_VERSION;
        $type = hexdec(TransactionType::REGISTER_NAMESPACE);
        if (is_string($networkType) && in_array(strtolower($networkType), ["mijin", "mijintest", "public", "publictest", "private", "privatetest", "NotSupportedNet", "aliasaddress"])){
            $networkType = Network::$networkInfos[strtolower($networkType)]["id"];
        }
        else if (is_numeric($networkType) && !in_array($networkType, [96, 144, 184, 168, 200, 176, 0, 145])) {
            throw new NISInvalidNetworkId("Invalid netword ID '" . $networkType . "'");
        } 
        $maxFee = array(0,0);
        $signature = ""; 
        $signer = new PublicAccount;
        $transactionInfo = new TransactionInfo;

        $abstractTransaction = new AbstractTransaction($transactionInfo,$deadline,$networkType,
                                                    $type,$version,$maxFee,$signature,$signer);
        $this->setAbstractTransaction($abstractTransaction);
        $this->parentId = IdGenerator::NewNamespaceIdFromName($parentName);
        $this->namespaceName = $namespaceName;
        $this->namespaceId = IdGenerator::generateNamespaceId($namespaceName,$this->parentId->getString());
        $this->namespaceType = NamespaceType::SUB;
        $this->duration = 0;

        return $this;
    }

    public function generateBytes() {
        $networkType = $this->getAbstractTransaction()->getNetworkType();
        $version = $this->getAbstractTransaction()->getVersion();
        $deadline = $this->getAbstractTransaction()->getDeadline();
        $signature = $this->getAbstractTransaction()->getSignature();
        $signer = $this->getAbstractTransaction()->getSigner();
        $maxFee = $this->getAbstractTransaction()->getMaxFee();
        $type = $this->getAbstractTransaction()->getType();

        $namespaceId = $this->namespaceId;
        $duration = $this->duration;
        $namespaceType = $this->namespaceType;
        $namespaceName = $this->namespaceName;
        $parentId = $this->parentId;

        $builder = new FlatbufferBuilder(1);

        $v = ($networkType << 8) + $version;
        // Create Vectors
        $signatureVector = RegisterNamespaceTransactionBuffer::createSignatureVector($builder, (new Utils)->createArrayZero(64));
        $signerVector = RegisterNamespaceTransactionBuffer::createSignerVector($builder, (new Utils)->createArrayZero(32));
        $deadlineVector = RegisterNamespaceTransactionBuffer::createDeadlineVector($builder, $deadline->getTimeArray());
        $feeVector = RegisterNamespaceTransactionBuffer::createMaxFeeVector($builder, $maxFee);
        $namespaceIdVector = RegisterNamespaceTransactionBuffer::createNamespaceIdVector($builder, $namespaceId->getId());
        if ($namespaceType == NamespaceType::ROOT){
            $durationParentIdVector = RegisterNamespaceTransactionBuffer::createDurationParentIdVector($builder, $duration);
        }
        else if ($namespaceType == NamespaceType::SUB){
            $durationParentIdVector = RegisterNamespaceTransactionBuffer::createDurationParentIdVector($builder, $parentId->getId());
        }
        

        // total size of transaction
        $size = 138;
        $name = $builder->createString($namespaceName);

        RegisterNamespaceTransactionBuffer::startRegisterNamespaceTransactionBuffer($builder);
        RegisterNamespaceTransactionBuffer::addSize($builder, $size + strlen($namespaceName));
        RegisterNamespaceTransactionBuffer::addSignature($builder, $signatureVector);
        RegisterNamespaceTransactionBuffer::addSigner($builder, $signerVector);
        RegisterNamespaceTransactionBuffer::addVersion($builder, $v);
        RegisterNamespaceTransactionBuffer::addType($builder, $type);
        RegisterNamespaceTransactionBuffer::addMaxFee($builder, $feeVector);
        RegisterNamespaceTransactionBuffer::addDeadline($builder, $deadlineVector);
        
        RegisterNamespaceTransactionBuffer::addNamespaceType($builder, $namespaceType);
        RegisterNamespaceTransactionBuffer::addDurationParentId($builder, $durationParentIdVector);
        RegisterNamespaceTransactionBuffer::addNamespaceId($builder, $namespaceIdVector);
        RegisterNamespaceTransactionBuffer::addNamespaceNameSize($builder, strlen($namespaceName));
        RegisterNamespaceTransactionBuffer::addNamespaceName($builder, $name);
        
        $codedTransaction = RegisterNamespaceTransactionBuffer::endRegisterNamespaceTransactionBuffer($builder);
        
        $builder->finish($codedTransaction);
        $RegisterNamespaceTransactionSchema = new RegisterNamespaceTransactionSchema;
        $tmp = unpack("C*",$builder->sizedByteArray());
        $builder_byte = array_slice($tmp,0,count($tmp));
        $output = $RegisterNamespaceTransactionSchema->serialize($builder_byte);
        return $output;
    }
}
?>