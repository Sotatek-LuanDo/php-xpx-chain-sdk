<?php
/**
 * NIS2 API
 *
 * This document defines all the nis2 api routes and behaviour
 *
 * OpenAPI spec version: 1.0.0
 * Contact: greg@evias.be
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 * 
 */

namespace NEM\Model\Transaction\Attribute;

/**
 * SchemaAttribute class Doc Comment
 *
 * @category class
 * @package  NEM
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
abstract class SchemaAttribute {
    private $name;

    public function __construct($name){
        $this->name = $name;
    }

    abstract protected function serialize3Params($buffer, $position, $innerObjectPosition);

    protected function serialize2Params($buffer, $position) {
        return $this->serialize3Params($buffer, $position, $buffer[0]);
    }

    public function __call($method, $arguments) {
        if($method == 'serialize') {
            if(count($arguments) == 2) {
               return call_user_func_array(array($this,'serialize2Params'), $arguments);
            }
            else if(count($arguments) == 3) {
               return call_user_func_array(array($this,'serialize3Params'), $arguments);
            }
        }
    }

    public function getName() {
        return $this->name;
    }

    protected function findParam($innerObjectPosition, $position, $buffer, $typeSize) {
        // var_dump("fP");
        // var_dump($innerObjectPosition);
        // var_dump($position);
        $offset = $this->__offset($innerObjectPosition, $position, $buffer);

        $from = $offset + $innerObjectPosition;
        //$to = $offset + $innerObjectPosition + $typeSize;
        //$noItems = $to - $from;

        if ($offset == 0){
            return array(0);
        }
        else return array_slice($buffer, $from, $typeSize);
        
    }

    protected function findVector($innerObjectPosition, $position, $buffer, $typeSize) {
        // var_dump("fV");
        // var_dump($position);
        $offset = $this->__offset($innerObjectPosition, $position, $buffer);
        $offsetLong = $offset + $innerObjectPosition;
        $vecStart = $this->__vector($offsetLong, $buffer);
        $vecLength = $this->__vector_length($offsetLong, $buffer) * $typeSize;
        if ($offset == 0){
            return array(0);
        }
        else return array_slice($buffer, $vecStart, $vecLength);
    }

    protected function findObjectStartPosition($innerObjectPosition, $position, $buffer) {
        //var_dump("fO");
        $offset = $this->__offset($innerObjectPosition, $position, $buffer);
        return $this->__indirect($offset + $innerObjectPosition, $buffer);
    }

    protected function findArrayLength($innerObjectPosition, $position, $buffer) {
        //var_dump("fA");
        $offset = $this->__offset($innerObjectPosition, $position, $buffer);
        if ($offset == 0){
            return 0;
        }
        else return  $this->__vector_length($innerObjectPosition + $offset, $buffer);
        
    }

    protected function findObjectArrayElementStartPosition($innerObjectPosition, $position, $buffer, $startPosition) {
        //var_dump("fOA");
        $offset = $this->__offset($innerObjectPosition, $position, $buffer);
        $vector = $this->__vector($innerObjectPosition + $offset, $buffer);
        return $this->__indirect($vector + $startPosition * 4, $buffer);
    }

    protected function readInt32($offset, $buffer) {
        /*final ByteBuffer bb = ByteBuffer.wrap(new byte[]{buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]});
        bb.order(ByteOrder.LITTLE_ENDIAN);
        return bb.getInt();*/
        $value = ($buffer[$offset + 3] << (8 * 3));
        $value |= ($buffer[$offset + 2] & 0xFF) << (8 * 2);
        $value |= ($buffer[$offset + 1] & 0xFF) << (8);
        $value |= ($buffer[$offset] & 0xFF);

        // var_dump("-------------readInt32---value--------------");
        // var_dump($value);
        // var_dump($buffer[$offset + 3]);
        // var_dump($buffer[$offset + 2]);
        // var_dump($buffer[$offset + 1]);
        // var_dump($buffer[$offset + 0]);
        // var_dump("------------------------------");
 
        return $value;
    }

    protected function readInt16($offset, $buffer) {
        /*final ByteBuffer bb = ByteBuffer.wrap(new byte[]{buffer[offset], buffer[offset + 1]});
        bb.order(ByteOrder.LITTLE_ENDIAN);
        return bb.getShort();*/
        $value = ($buffer[$offset + 1] & 0xFF) << (8);
        $value |= ($buffer[$offset] & 0xFF);
        return $value;
    }

    protected function __offset($innerObjectPosition, $position, $buffer) {
        $tmp = $this->readInt32($innerObjectPosition, $buffer);
        if ($tmp > 255){
            $tmp = $tmp | 0xFFFFFFFF00000000;
        }
        $vtable = $innerObjectPosition - $tmp;
        // var_dump("------innerObj---position-----vtable---------");
        // var_dump($innerObjectPosition);
        // var_dump($position);
        // var_dump($tmp);
        // var_dump($vtable);
        // var_dump("------------------------------");
        return $position < $this->readInt16($vtable, $buffer) ? $this->readInt16($vtable + $position, $buffer) : 0;
    }

    protected function __vector_length($offset, $buffer) {
        return $this->readInt32($offset + $this->readInt32($offset, $buffer), $buffer);
    }

    protected function __indirect($offset, $buffer) {
        return $offset + $this->readInt32($offset, $buffer);
    }

    protected function __vector($offset, $buffer) {
        return $offset + $this->readInt32($offset, $buffer) + 4;
    }
}
?>