<?php
/**
 * NIS2 API
 *
 * This document defines all the nis2 api routes and behaviour
 *
 * OpenAPI spec version: 1.0.0
 * Contact: greg@evias.be
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 * 
 */

namespace NEM\Model\Transaction;

use NEM\Model\TransactionType;
use NEM\Model\Deadline;
use NEM\Model\TransactionVersion;
use NEM\Model\TransactionInfo;
use NEM\Model\PublicAccount;
use NEM\Infrastructure\Network;
use NEM\Model\Transaction\Schema\AggregateTransactionSchema;
use \Google\FlatBuffers\FlatbufferBuilder;
use \Catapult\Buffers\MessageBuffer;
use \Catapult\Buffers\MosaicBuffer;
use \Catapult\Buffers\AggregateTransactionBuffer;

/**
 * AggregateTransaction class Doc Comment
 *
 * @category class
 * @package  NEM
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class AggregateTransaction extends \NEM\Model\Transaction{

    private $innerTransactions;
     
    public function __construct($deadline, $innerTransactions, $networkType){
        $abstractTransaction = new \stdClass();
        $abstractTransaction->version = TransactionVersion::AGGREGATE_BONDED_VERSION;
        $abstractTransaction->deadline = $deadline;
        $abstractTransaction->type = hexdec(TransactionType::AGGREGATE_BONDED);
        if (is_string($networkType) && in_array(strtolower($networkType), ["mijin", "mijintest", "public", "publictest", "private", "privatetest", "NotSupportedNet", "aliasaddress"])){
            $networkType = Network::$networkInfos[strtolower($networkType)]["id"];
        }
        else if (is_numeric($networkType) && !in_array($networkType, [96, 144, 184, 168, 200, 176, 0, 145])) {
            throw new NISInvalidNetworkId("Invalid netword ID '" . $networkType . "'");
        } 
        $abstractTransaction->networkType = $networkType;

        $abstractTransaction->maxFee = array(0,0);
        $abstractTransaction->signature = ""; 
        $abstractTransaction->signer = new PublicAccount;
        $abstractTransaction->transactionInfo = new TransactionInfo;

        $this->setAbstractTransaction($abstractTransaction);
        $this->innerTransactions = $innerTransactions;
    }

    public function generateBytes() {
        $networkType = $this->getAbstractTransaction()->networkType;
        $version = $this->getAbstractTransaction()->version;
        $deadline = $this->getAbstractTransaction()->deadline;
        $signature = $this->getAbstractTransaction()->signature;
        $signer = $this->getAbstractTransaction()->signer;
        $maxFee = $this->getAbstractTransaction()->maxFee;
        $type = $this->getAbstractTransaction()->type;

        $innerTransactions = $this->innerTransactions;

        $builder = new FlatbufferBuilder(1);

        // Create transactionsBytes
        for ($i=0;$i<count($innerTransactions);$i++) {
            $transactionBytes = $innerTransactions[$i]->toAggregateTransactionBytes();
            $transactionsBytes = array_merge($transactionsBytes, $transactionBytes);
        }

        $v = ($networkType << 8) + $version;
        // Create Vectors
        $signatureVector = AggregateTransactionBuffer::createSignatureVector($builder, array());
        $signerVector = AggregateTransactionBuffer::createSignerVector($builder, array());
        $deadlineVector = AggregateTransactionBuffer::createDeadlineVector($builder, $deadline->getTimeArray());
        $feeVector = AggregateTransactionBuffer::createFeeVector($builder, $maxFee);
        $transactionsVector = AggregateTransactionBuffer::createTransactionsVector($builder, $transactionsBytes);

        
        AggregateTransactionBuffer::startAggregateTransactionBuffer($builder);
        AggregateTransactionBuffer::addSize($builder, 120 + 4 + count($transactionsBytes));
        AggregateTransactionBuffer::addSignature($builder, $signatureVector);
        AggregateTransactionBuffer::addSigner($builder, $signerVector);
        AggregateTransactionBuffer::addVersion($builder, $version);
        AggregateTransactionBuffer::addType($builder, $type);
        AggregateTransactionBuffer::addFee($builder, $feeVector);
        AggregateTransactionBuffer::addDeadline($builder, $deadlineVector);

        AggregateTransactionBuffer::addTransactionsSize($builder, count($transactionsBytes));
        AggregateTransactionBuffer::addTransactions($builder, $transactionsVector);

        $codedTransaction = AggregateTransactionBuffer::endAggregateTransactionBuffer($builder);
        $builder->finish($codedTransaction);
        $AggregateTransactionBufferSchema = new AggregateTransactionBufferSchema;
        $tmp = unpack("C*",$builder->sizedByteArray());
        $builder_byte = array_slice($tmp,0,count($tmp));
        $output = $AggregateTransactionBufferSchema->serialize($builder_byte,0);
        return $output;
    }
}
?>