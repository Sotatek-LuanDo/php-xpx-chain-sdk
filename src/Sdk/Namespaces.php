<?php
/**
 * NIS2 API
 *
 * This document defines all the nis2 api routes and behaviour
 *
 * OpenAPI spec version: 1.0.0
 * Contact: greg@evias.be
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 * 
 */

namespace Proximax\Sdk;

use Proximax\API\NamespaceRoutesApi;
use Proximax\ApiClient;
use Base32\Base32;
use Proximax\Model\UInt64DTO;
use Proximax\Model\NamespaceMetaDTO;
use Proximax\Model\AliasDTO;
use Proximax\Model\NamespaceDTO;
use Proximax\Model\NamespaceInfoDTO;
use Proximax\Model\NamespaceNameDTO;
/**
 * Namespaces class Doc Comment
 *
 * @category class
 * @package  Proximax
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Namespaces{
    /**
     *
     * @param config $config
     *
     * @param namespaceId
     * 
     * @return NamespaceInfoDTO
     */
    public function GetNamespace($config, $namespaceId){
        $NamespaceRoutesApi = new NamespaceRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $NamespaceRoutesApi->getNamespace($namespaceId);
        if ($data[1] == 200){ // successfull
            $namespace = $this->formatData($networkType, $data[0]);
        }
        else $namespace = null;
        return new NamespaceInfoDTO($namespace);
    }

    /**
     *
     * @param config $config
     *
     * @param $accountId
     *  
     * @param int $pageSize The numbers of namespace to return (optional)
     * 
     * @param string $id Id last namespace id to apply pagination (optional)
     * 
     * @return NamespaceInfoDTO
     */
    public function GetNamespaceFromAccount($config, $accountId,$pageSize, $id){
        $NamespaceRoutesApi = new NamespaceRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $NamespaceRoutesApi->getNamespacesFromAccount($accountId,$pageSize, $id);
        $namespaces = array();
        if ($data[1] == 200){ // successfull
            for ($i=0;$i<count($data[0]);$i++){
                $namespace = $this->formatData($networkType, $data[0][$i]);
                $namespaces[$i] = new NamespaceInfoDTO($namespace);
            }
            
        }
        return $namespaces;
    }

    /**
     *
     * @param config $config
     *
     * @param $accountIds is array publicKey or address 
     *  
     * @param int $pageSize The numbers of namespace to return (optional)
     * 
     * @param string $id Id last namespace id to apply pagination (optional)
     * 
     * @return NamespaceInfoDTO
     */
    public function GetNamespaceFromAccounts($config, $accountIds, $pageSize, $id){
        $NamespaceRoutesApi = new NamespaceRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $NamespaceRoutesApi->getNamespacesFromAccounts($accountIds,$pageSize, $id);
        $namespaces = array();
        if ($data[1] == 200){ // successfull
            for ($i=0;$i<count($data[0]);$i++){
                $namespace = $this->formatData($networkType, $data[0][$i]);
                $namespaces[$i] = new NamespaceInfoDTO($namespace);
            }
            
        }
        return $namespaces;
    }

    /**
     *
     * @param config $config
     *
     * @param namespaceId
     * 
     * @return NamespaceInfoDTO
     */
    public function GetNamespacesNames($config, $namespaceIds){
        $NamespaceRoutesApi = new NamespaceRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $NamespaceRoutesApi->getNamespacesNames($namespaceIds);
        $namespaceNames = array();
        if ($data[1] == 200){ // successfull
            for($i=0;$i<count($data[0]);$i++){
                $namespace = $this->formatDataName($networkType, $data[0][$i]);
                $namespaceNames[$i] = new NamespaceNameDTO($namespace);
            }
            
        }
        return $namespaceNames;
    }

    /**
     * @param int $networkType
     *
     * @param object $data
     * 
     * @return NamespaceInfoDTO
     */
    private function formatData($networkType, $data){
        $id = $data->meta->id;
        $active = $data->meta->active;
        $index = $data->meta->index;

        $namespacesMetaDTO = array(
            "id" => $id,
            "active" => $active,
            "index" => $index
        );
        $meta = new NamespaceMetaDTO($namespacesMetaDTO);

        $owner = $data->namespace->owner;

        $hex = new \Proximax\Utils\Hex;
        $ownerAddress = $hex->DecodeString($data->namespace->ownerAddress);
        $ownerAddress = Base32::encode(implode(array_map("chr", $ownerAddress)));

        $startHeight = new UInt64DTO($data->namespace->startHeight);
        $endHeight = new UInt64DTO($data->namespace->endHeight);
        $depth = $data->namespace->depth;
        $level0 = new UInt64DTO($data->namespace->level0);
        if (isset($data->namespace->level1)){
            $level1 = new UInt64DTO($data->namespace->level1);
        }
        else $level1 = null;

        if (isset($data->namespace->level2)){
            $level2 = new UInt64DTO($data->namespace->level2);
        }
        else $level2 = null;
        $type = $data->namespace->type;

        $aliasType = $data->namespace->alias->type;
        if (isset($data->namespace->alias->mosaicId)){
            $mosaicId = $data->namespace->alias->mosaicId;
        }
        else $mosaicId = null;

        if (isset($data->namespace->alias->address)){
            $address = $data->namespace->alias->address;
        }
        else $address = null;

        $aliasDTO = array(
            "type" => $aliasType,
            "mosaicId" => $mosaicId,
            "address" => $address
        );
        $alias = new AliasDTO($aliasDTO);
        $parentId = new UInt64DTO($data->namespace->parentId);

        $namespacesDTO = array(
            "owner" => $owner,
            "ownerAddress" => $ownerAddress,
            "startHeight" => $startHeight,
            "endHeight" => $endHeight,
            "depth" => $depth,
            "level0" => $level0,
            "level1" => $level1,
            "level2" => $level2,
            "type" => $type,
            "alias" => $alias,
            "parentId" => $parentId
        );
        $namespace = new NamespaceDTO($namespacesDTO);
        $namespaceInfoDTO = array(
            "meta" => $meta,
            "namespace" => $namespace,
        );
        return $namespaceInfoDTO;
    }


    /**
     * @param int $networkType
     *
     * @param object $data
     * 
     * @return NamespaceNameDTO
     */
    private function formatDataName($networkType, $data){
        $namespaceId = new UInt64DTO($data->namespaceId);
        $name = $data->name;
        $namespaceNameDTO = array(
            "namespaceId" => $namespaceId,
            "name" => $name,
        );
        return $namespaceNameDTO;
    }
}
?>