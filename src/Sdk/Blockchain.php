<?php
/**
 * NIS2 API
 *
 * This document defines all the nis2 api routes and behaviour
 *
 * OpenAPI spec version: 1.0.0
 * Contact: greg@evias.be
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 * 
 */

namespace NEM\Sdk;
use NEM\API\BlockchainRoutesApi;
use NEM\ApiClient;
use NEM\Model\HeightDTO;
use NEM\Infrastructure\TransactionMapping;
use NEM\Model\Account;
use NEM\Model\BlockInfoDTO;
use NEM\Model\BlockchainStorageInfo;

/**
 * Blockchain class Doc Comment
 *
 * @category class
 * @package  NEM
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Blockchain{
    /**
     *
     * @param config $config
     * 
     * @return HeightDTO
     */
    public function GetBlockchainHeight($config){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $BlockchainRoutesApi->getBlockchainHeight();
        if ($data[1] == 200){ // successfull
            return new HeightDTO($data[0]->height);
        }
        else return new HeightDTO;

        
    }

    /**
     *
     * @param config $config
     *
     * @param int $height
     * 
     * @return BlockInfoDTO array
     */
    public function GetBlockByHeight($config, $height){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;

        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;
        var_dump("111111111");
        $data = $BlockchainRoutesApi->getBlockByHeight($height);

        if ($data[1] == 200){ // successfull
            var_dump("222222222222");
            $blockInfo = $this->formatDataBlock($networkType,$data[0]);
            return new BlockInfoDTO($blockInfo);
        }
        else return new BlockInfoDTO;
    }

        /**
     *
     * @param config $config
     *
     * @param int $height
     * 
     * @return BlockInfoDTO array
     */
    public function GetBlockByHeightWithLimit($config, $height, $limit){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;

        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;
        $data = $BlockchainRoutesApi->getBlocksByHeightWithLimit($height,$limit);

        $blockInfo_array = array();
        if ($data[1] == 200){ // successfull
            for($i=0;$i<count($data[0]);$i++){
                $blockInfo = $this->formatDataBlock($networkType,$data[0][$i]);
                $blockInfo_array[$i] = new BlockInfoDTO($blockInfo);
            }
            return $blockInfo_array;
        }
        else return $blockInfo_array;
    }

    /**
     *
     * @param config $config
     * 
     * @param int $height
     * 
     * @return HeightDTO
     */
    public function GetBlockTransactions($config,$height){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $BlockchainRoutesApi->getBlockTransactions($height);
        $transactions = array();
        if ($data[1] == 200){ // successfull
            for($i=0;$i<count($data[0]);$i++){
                $transactions[$i] = (new Transaction)->formatData($networkType,$data[0][$i]);
            }
            return $transactions;
        }
        else return null;
    }

    /**
     *
     * @param config $config
     * 
     * @return  int
     */
    public function GetBlockchainScore($config){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $BlockchainRoutesApi->getBlockchainScore();
        $transactions = array();
        if ($data[1] == 200){ // successfull
            return (new TransactionMapping)->ExtractCurrentScore($data[0]);
        }
        else return null;
    }

    /**
     *
     * @param config $config
     * 
     * @return BlockchainStorageInfo
     */
    public function GetBlockchainStorage($config){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $BlockchainRoutesApi->getDiagnosticStorage();
        $transactions = array();
        if ($data[1] == 200){ // successfull
            return new BlockchainStorageInfo($data[0]->numBlocks,$data[0]->numTransactions,$data[0]->numAccounts);
        }
        else return null;
    }

    /**
     * @param int $networkType
     *
     * @param array $data
     * 
     * @return BlockInfoDTO array
     */
    private function formatDataBlock($networkType, $data){
        $TransactionMapping = new TransactionMapping;
        $hash = $data->meta->hash;
        $generationHash = $data->meta->generationHash;
        $totalFee = $TransactionMapping->ExtractMaxFee($data->meta->totalFee);
        $numTransactions = $data->meta->numTransactions;

        $signature = $data->block->signature;
        $signer = (new Account)->newAccountFromPublicKey($data->block->signer,$networkType);
        $version = $TransactionMapping->ExtractVersion($data->block->version);
        $type = $data->block->type;
        $height = new HeightDTO($data->block->height);
        $timestamp = $TransactionMapping->ExtractDeadline($data->block->timestamp);
        $difficulty = $TransactionMapping->ExtractDifficulty($data->block->difficulty);
        $feeMultiplier = $data->block->feeMultiplier;
        $previousBlockHash = $data->block->previousBlockHash;
        $blockTransactionsHash = $data->block->blockTransactionsHash;
        $blockReceiptsHash = $data->block->blockReceiptsHash;
        $stateHash = $data->block->stateHash;
        $beneficiaryPublicKey = $data->block->beneficiaryPublicKey;

        $blockInfo = array(
            'hash' => $hash,
            'generationHash' => $generationHash,
            'totalFee' => $totalFee,
            'numTransactions' => $numTransactions,
            'signature' => $signature,
            'signer' => $signer,
            'version' => $version,
            'type' => $type,
            'height' => $height,
            'timestamp' => $timestamp,
            'difficulty' => $difficulty,
            'feeMultiplier' => $feeMultiplier,
            'previousBlockHash' => $previousBlockHash,
            'blockTransactionsHash' => $blockTransactionsHash,
            'blockReceiptsHash' => $blockReceiptsHash,
            'stateHash' => $stateHash,
            'beneficiaryPublicKey' => $beneficiaryPublicKey
        );
        return $blockInfo;
    }
}
?>