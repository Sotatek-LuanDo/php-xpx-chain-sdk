<?php
/**
 * NIS2 API
 *
 * This document defines all the nis2 api routes and behaviour
 *
 * OpenAPI spec version: 1.0.0
 * Contact: greg@evias.be
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 * 
 */

namespace Proximax\Core;

use Proximax\Core\KeyPair;
use Proximax\Core\Buffer;
use Proximax\Core\Encryption;
use Proximax\Errors\NISInvalidSignatureContent;
use \ParagonIE_Sodium_Compat;
use \ParagonIE_Sodium_Core_Ed25519;
USE \SodiumException;

/**
 * Signature class Doc Comment
 *
 * @category class
 * @package  Proximax
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Signature
    extends ParagonIE_Sodium_Core_Ed25519
{
    /**
     * Public Key of the Signer in Hexadecimal Format (32 bytes).
     * 
     * @var \Proximax\Core\Buffer
     */
    protected $signer;

    /**
     * Generated Signature in Hexadecimal Format (64 bytes)
     * 
     * @var \Proximax\Core\Buffer
     */
    protected $signature;

    /**
     * Holds the Encryption algorithm name.
     * 
     * This is to provide more flexibility when it comes
     * to signatures with keccak-512, sha-512, etc.
     * 
     * @see https://php.net/hash_algos
     * @var string
     */
    protected $algorithm;

    /**
     * This method creates a Signature of said `data` with the
     * given `keyPair` KeyPair object.
     *
     * @param   \Proximax\Core\KeyPair          $keyPair      The KeyPair object with which you want to sign `data`.
     * @param   string|\Proximax\Core\Buffer    $data         The data that needs to be signed.
     * @param   null|string                $algorithm    The hash algorithm that you wish to use for signature creation.
     * @return  \Proximax\Core\Signature
     * @throws  \Proximax\Errors\NISInvalidSignatureContent      On invalid `data` argument. Should be a \Proximax\Core\Buffer or a string.
     */
    static public function create(KeyPair $kp, $data, $algorithm = 'sha3-512')
    {
        $sig = new static($privateKey, $publicKey, $algorithm);
        return $sig;
    }

    /**
     * Signature object constructor.
     *
     * @param   \Proximax\Core\KeyPair          $keyPair      The KeyPair object with which you want to sign `data`.
     * @param   string|\Proximax\Core\Buffer    $data         The data that needs to be signed.
     * @param   null|string                $algorithm    The hash algorithm that you wish to use for signature creation.
     * @return  void
     * @throws  \Proximax\Errors\NISInvalidSignatureContent      On invalid `data` argument. Should be a \Proximax\Core\Buffer or a string.
     */
    public function __construct(KeyPair $kp, $data, $algorithm = 'sha3-512')
    {
        // wrap data in internal \Proximax\Core\Buffer class
        $this->prepareData($data);

        $this->algorithm = $algorithm ?: "sha3-512";
        $this->signature = Encryption::sign($kp, $this->data, $algorithm);
        $this->signer = $kp->getPublicKey();
    }

    /**
     * Getter for the `signer` property.
     * 
     * @return \Proximax\Core\Buffer
     */
    public function getSigner()
    {
        return $this->signer;
    }

    /**
     * Getter for the `signature` property.
     * 
     * @return \Proximax\Core\Buffer
     */
    public function getSignature()
    {
        return $this->signature;
    }

    /**
     * This method will prepare the given data and populate the
     * `data` property with a prepared and correctly sized Buffer.
     * 
     * @param   string|\Proximax\Core\Buffer    $data         The data that needs to be signed.
     * @return  \Proximax\Core\Signature
     * @throws  \Proximax\Errors\NISInvalidSignatureContent      On invalid `data` argument. Should be a \Proximax\Core\Buffer or a string.
     */
    protected function prepareData($data) 
    {
        if ($data instanceof Buffer) {
            $this->data = $data;
        }
        elseif (is_string($data)) {
            $this->data = new Buffer($data); // auto-sized
        }
        elseif (is_array($data)) {
            // Uint8 provided (serialized data)
            $this->data = Buffer::fromUInt8($data);
        }
        else {
            throw new NISInvalidSignatureContent("Invalid content provided for \\Proximax\\Core\\Signature object.");
        }

        return $this;
    }

}
